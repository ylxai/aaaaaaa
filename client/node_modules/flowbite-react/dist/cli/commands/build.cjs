'use strict';

var fs = require('fs/promises');
var consts = require('../consts.cjs');
var buildClassList = require('../utils/build-class-list.cjs');
var extractComponentImports = require('../utils/extract-component-imports.cjs');
var findFiles = require('../utils/find-files.cjs');
var getConfig = require('../utils/get-config.cjs');
var setupInit = require('./setup-init.cjs');
var setupOutputDirectory = require('./setup-output-directory.cjs');

async function build() {
  await setupOutputDirectory.setupOutputDirectory();
  try {
    const config = await getConfig.getConfig();
    await setupInit.setupInit(config);
    const importedComponents = [];
    if (config.components.length) {
      console.warn(consts.automaticClassGenerationMessage);
    } else {
      const files = await findFiles.findFiles({
        patterns: consts.allowedExtensions.map((ext) => `**/*${ext}`),
        excludeDirs: consts.excludeDirs
      });
      for (const file of files) {
        const content = await fs.readFile(file, "utf-8");
        const components = extractComponentImports.extractComponentImports(content);
        if (components.length) {
          importedComponents.push(...components);
        }
      }
    }
    const classList = buildClassList.buildClassList({
      components: config.components.length ? config.components : [...new Set(importedComponents)],
      dark: config.dark,
      prefix: config.prefix,
      version: config.version
    });
    console.log(`Generating ${consts.classListFilePath} file...`);
    await fs.writeFile(consts.classListFilePath, JSON.stringify(classList, null, 2));
  } catch (error) {
    console.error(`Failed to generate ${consts.classListFilePath}:`, error);
  }
}

exports.build = build;
//# sourceMappingURL=build.cjs.map
